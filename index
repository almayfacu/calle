<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>CrashALMA — joystick móvil (velocidad ajustada)</title>
<style>
  :root{
    --bg:#d7eef0;
    --road-dark:#222;
    --road-light:#3e3e3e;
    --sidewalk:#dcdcdc;
    --accent-pink:#ff6699;
    --accent-dark:#123;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg,var(--bg),#cfeee8);
    font-family:'Comic Sans MS';padding:0;user-select:none;
    -webkit-user-select:none;
    height:100vh; width:100vw;
  }

  /* Start Menu */
  #startMenu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:1000;background:rgba(0,0,0,0.35)}
  #startCard{background:linear-gradient(180deg,#fff,#f3f6f7);padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.25);text-align:center;min-width:300px}
  #startCard h2{margin:6px 0 12px;color:var(--accent-dark)}
  .radioRow{display:flex;gap:8px;justify-content:center;margin-bottom:12px}
  .radioBtn{background:linear-gradient(180deg,#ffebf0,#ffd6e1);border:2px solid rgba(255,102,153,0.25);color:#62163a;padding:8px 14px;border-radius:10px;cursor:pointer;font-weight:700}
  .radioBtn.active{background:linear-gradient(180deg,var(--accent-pink),#ff3b81);color:#fff;border-color:rgba(255,51,102,0.9)}
  #startBtn{background:var(--accent-pink);color:white;border:none;padding:10px 16px;border-radius:10px;cursor:pointer;font-weight:800}

  /* Game container full viewport */
  #gameContainer{
    --player-w:96px; --player-h:96px; --car-w:180px; --car-h:105px;
    position:fixed; inset:0; overflow:hidden; background:transparent;
    touch-action:none;
  }

  .sidewalk{position:absolute;left:0;right:0;height:8%;background:linear-gradient(180deg,var(--sidewalk),#d6d6d6);z-index:200}
  .sidewalk.top{top:0}.sidewalk.bottom{bottom:0}

  .road{
    position:absolute;left:5%;right:5%;top:8%;bottom:8%;
    background: linear-gradient(180deg,var(--road-dark),var(--road-light));
    box-shadow: inset 0 8px 30px rgba(0,0,0,0.25);
    z-index:100; overflow:hidden;
  }
  .road::before{
    content:'';position:absolute;inset:0;background-image:
      radial-gradient(rgba(255,255,255,0.01) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.01) 1px, transparent 1px);
    background-size: 12px 12px, 120px 120px;opacity:0.06;pointer-events:none;
  }

  .laneSeparator{
    position:absolute;left:10%;width:80%;height:8px;border-radius:6px;
    background:repeating-linear-gradient(90deg, rgba(255,255,255,0.95) 0 20px, rgba(255,255,255,0.07) 20px 40px);
    opacity:0.95;z-index:160;box-shadow:0 3px 8px rgba(0,0,0,0.08);
  }

  .edgeRumble{position:absolute;width:4%;top:0;bottom:0;background:linear-gradient(180deg, rgba(0,0,0,0.07), rgba(255,255,255,0.02));left:5%;z-index:150}
  .edgeRumble.right{left:auto;right:5%}
  .reflector{position:absolute;width:6px;height:6px;border-radius:50%;background:yellow;opacity:0.9;box-shadow:0 0 8px rgba(255,255,0,0.12);}

  .crosswalk{position:absolute;top:4%;left: calc(5% + 6%);right: calc(5% + 6%);height:8%;display:flex;justify-content:space-between;align-items:center;pointer-events:none;z-index:210}
  .crosswalk .bar{width:8%;height:60%;background:white;opacity:0.98;border-radius:3px;box-shadow:0 2px 8px rgba(0,0,0,0.07)}

  #player{
    position:absolute;width:var(--player-w);height:var(--player-h);
    bottom:8%;left:calc(50% - (var(--player-w) / 2));
    background:transparent center/contain no-repeat;border-radius:12px;z-index:400;overflow:visible;
    box-shadow:0 12px 26px rgba(0,0,0,0.18);
  }
  .car{
    position:absolute;width:var(--car-w);height:var(--car-h);z-index:350;pointer-events:none;overflow:visible;
    display:flex;align-items:center;justify-content:center;
  }
  .car img{width:100%;height:100%;object-fit:contain;display:block;pointer-events:none;user-select:none}

  #gameOverScreen{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1001;background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0.65))}
  #gameOverCard{background:linear-gradient(180deg,#fff,#f5f7f8);padding:18px;border-radius:12px;text-align:center;min-width:320px;box-shadow:0 12px 30px rgba(0,0,0,0.25)}
  #gameOverCard h3{margin:0 0 8px;color:#7a0a2e}
  #retryBtn{background:var(--accent-pink);color:white;border:none;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:800}

  #winScreen{position:fixed;inset:0;background:rgba(0,0,0,0.82);color:#fff;display:none;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:18px;z-index:1001}
  #winScreen img{max-width:82%;max-height:86%;border-radius:12px;box-shadow:0 12px 36px rgba(0,0,0,0.6);margin-bottom:12px}
  .winBtns{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
  .btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600}
  .btn.primary{background:#1db954;color:white}.btn.secondary{background:#333;color:white}

  /* JOYSTICK (móvil): esquina inferior izquierda */
  #joystick {
    position:fixed;
    left:14px;
    bottom:14px;
    width:120px;
    height:120px;
    z-index:1300;
    display:none; /* se muestra sólo si detectamos touch */
    touch-action:none;
    -webkit-tap-highlight-color: transparent;
  }
  #joystickBase{
    position:absolute; inset:0; border-radius:50%;
    background: rgba(0,0,0,0.18);
    display:flex;align-items:center;justify-content:center;
    box-shadow: 0 6px 18px rgba(0,0,0,0.22);
  }
  #joystickKnob{
    width:54px;height:54px;border-radius:50%;
    background: rgba(255,255,255,0.95);
    display:block; transform: translate(0,0);
    box-shadow: 0 8px 18px rgba(0,0,0,0.25);
    transition: transform 0.06s linear;
  }

  @media (max-width:600px){
    #joystick{ width:96px; height:96px; left:10px; bottom:10px; }
    #joystickKnob{ width:44px; height:44px; }
  }
</style>
</head>
<body>

<!-- START MENU -->
<div id="startMenu" aria-hidden="false">
  <div id="startCard">
    <h2>Elegí la dificultad</h2>
    <div class="radioRow" role="tablist" aria-label="Dificultades">
      <label class="radioBtn" data-val="easy"><input type="radio" name="diff" value="easy" style="display:none">Fácil</label>
      <label class="radioBtn active" data-val="medium"><input type="radio" name="diff" value="medium" checked style="display:none">Medio</label>
      <label class="radioBtn" data-val="hard"><input type="radio" name="diff" value="hard" style="display:none">Difícil</label>
    </div>
    <button id="startBtn">Iniciar</button>
  </div>
</div>

<!-- GAME -->
<div id="gameContainer" aria-hidden="true">
  <div class="sidewalk top"></div>
  <div class="road" id="road"></div>
  <div class="sidewalk bottom"></div>

  <div class="edgeRumble" aria-hidden="true"></div>
  <div class="edgeRumble right" aria-hidden="true"></div>

  <div class="crosswalk" id="crosswalk" aria-hidden="true"></div>
  <div id="player" aria-label="Jugador"></div>

  <div id="gameOverScreen" aria-hidden="true">
    <div id="gameOverCard">
      <h3>¡Te atropellaron!</h3>
      <div style="margin-top:6px;color:#444">¿Querés intentarlo de nuevo?</div>
      <div style="margin-top:12px"><button id="retryBtn">Volver a intentar</button></div>
    </div>
  </div>

  <div id="winScreen" role="dialog" aria-modal="true">
    <img id="winImage" src="" alt="Felicidades">
    <div class="winBtns">
      <button class="btn secondary" onclick="restartSameMode()">Jugar otra vez</button>
      <button class="btn primary" onclick="showStartMenu()">Volver a inicio</button>
    </div>
  </div>

  <!-- JOYSTICK móvil (se muestra solo en touch devices) -->
  <div id="joystick" aria-hidden="true" aria-label="Joystick">
    <div id="joystickBase"><div id="joystickKnob"></div></div>
  </div>
</div>

<script>
/* CONFIG */
const CONFIG = {
  initialDifficulty: 'medium',
  playerImage: 'player.png',
  carImages: ['rojo.png','azul.png','amarillo.png'],
  hornSounds: ['horns.mp3','horns1.mp3'],
  soundCrash: 'crash.mp3',
  soundWin: 'win.mp3',
  winImage: 'chispa.png'
};

/* ELEMENTS */
const startMenu = document.getElementById('startMenu');
const startBtn = document.getElementById('startBtn');
const radioBtns = document.querySelectorAll('.radioBtn');
const gameContainer = document.getElementById('gameContainer');
const road = document.getElementById('road');
const player = document.getElementById('player');
const crosswalk = document.getElementById('crosswalk');
const gameOverScreen = document.getElementById('gameOverScreen');
const retryBtn = document.getElementById('retryBtn');
const winScreen = document.getElementById('winScreen');
const winImageEl = document.getElementById('winImage');
const joystick = document.getElementById('joystick');
const joystickBase = document.getElementById('joystickBase');
const joystickKnob = document.getElementById('joystickKnob');

let cars = [], gameOver=false, spawnIntervalId=null, rafId=null, loopRunning=false, rampIntervalId=null;
let currentMode = CONFIG.initialDifficulty || 'medium';
const modes = {
  easy:   { speed: 4.2, spawnRate: 700, baseLaneCount: 4, speedVariance: 0.7, label:'FÁCIL' },
  medium: { speed: 6.2, spawnRate: 480, baseLaneCount: 5, speedVariance: 0.9, label:'MEDIO' },
  hard:   { speed: 10.0, spawnRate: 320, baseLaneCount: 6, speedVariance: 1.2, label:'DIF' }
};
let lanes=[], playerX=0, playerY=0;
let activeLaneCount = 0;

/* audio */
let hornAudios = [];
let hornPaths = Array.isArray(CONFIG.hornSounds) ? CONFIG.hornSounds.slice() : [];
let backgroundHorn = null;
let audioCrash = null;
let audioWin = null;

/* preloaded images */
let configuredCarImages = [];
let configuredPlayerImage = null;
let configuredWinImage = null;

/* game difficulty multipliers (ramping) */
let gameSpeedMultiplier = 1;
let currentSpawnRate = 800;

/* INPUT STATES */
let joystickVector = { x:0, y:0 }; // [-1..1]
let keyboardVector = { x:0, y:0 }; // [-1..1]
let lastFrameTime = performance.now();

/* Detect touch device and apply mobile difficulty adjustments */
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const mobileSpeedMultiplier = isTouchDevice ? 0.85 : 1.0;   // coches más lentos en móvil
const mobileSpawnMultiplier = isTouchDevice ? 1.25 : 1.0;    // menos spawns en móvil (más fácil)

/* ---------- AJUSTE DE VELOCIDAD DEL JUGADOR ---------- */
// Ahora la velocidad del player es mayor en dispositivos táctiles, igual que pediste.
// Mantengo la velocidad antigua en desktop (0.10). En móvil uso 0.30 (ajustable).
const playerSpeedMultiplier = isTouchDevice ? 0.30 : 0.10; // <-- cambio clave: móvil más rápido

/* ---------- fallbacks SVGs ---------- */
function carSvgDataUri(color='#ff4d4d'){
  const svg = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 140 80'><g><rect x='16' y='24' rx='8' width='108' height='32' fill='${color}'/><rect x='44' y='6' rx='8' width='52' height='28' fill='rgba(255,255,255,0.15)'/><circle cx='40' cy='62' r='7' fill='#222'/><circle cx='104' cy='62' r='7' fill='#222'/></g></svg>`;
  return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
}
const defaultPlayerURI = `data:image/svg+xml;utf8,${encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120'><g><circle cx='60' cy='34' r='20' fill='%23ffb3c6'/><path d='M40 60 q20 28 40 0 v20 h-40 z' fill='%23ff7aa2'/></g></svg>")}`;

/* ---------- PRELOAD ---------- */
function preloadImagesAndSounds(){
  return new Promise((resolve) => {
    const carPaths = Array.isArray(CONFIG.carImages) ? CONFIG.carImages.slice() : [];
    const horns = Array.isArray(CONFIG.hornSounds) ? CONFIG.hornSounds.slice() : [];
    const playerPath = CONFIG.playerImage || null;
    const winPath = CONFIG.winImage || null;

    const tasks = [];
    const goodCars = [];

    carPaths.forEach(path => {
      tasks.push(new Promise(res => {
        const img = new Image();
        img.onload = ()=>{ goodCars.push(path); res(); };
        img.onerror = ()=>{ res(); };
        img.src = path;
      }));
    });

    if(playerPath){
      tasks.push(new Promise(res=>{
        const img = new Image();
        img.onload = ()=>{ configuredPlayerImage = playerPath; res(); };
        img.onerror = ()=>{ configuredPlayerImage = null; res(); };
        img.src = playerPath;
      }));
    }

    if(winPath){
      tasks.push(new Promise(res=>{
        const img = new Image();
        img.onload = ()=>{ configuredWinImage = winPath; res(); };
        img.onerror = ()=>{ configuredWinImage = null; res(); };
        img.src = winPath;
      }));
    }

    horns.forEach(path=>{
      tasks.push(new Promise(res=>{
        const a = new Audio();
        a.preload = 'auto';
        a.oncanplaythrough = ()=>{ hornAudios.push(a); res(); };
        a.onerror = ()=>{ res(); };
        a.src = path;
      }));
    });

    if(CONFIG.soundCrash){
      tasks.push(new Promise(res=>{
        const ac = new Audio(); ac.preload='auto';
        ac.oncanplaythrough = ()=>{ audioCrash = ac; res(); };
        ac.onerror = ()=>{ res(); };
        ac.src = CONFIG.soundCrash;
      }));
    }
    if(CONFIG.soundWin){
      tasks.push(new Promise(res=>{
        const aw = new Audio(); aw.preload='auto';
        aw.oncanplaythrough = ()=>{ audioWin = aw; res(); };
        aw.onerror = ()=>{ res(); };
        aw.src = CONFIG.soundWin;
      }));
    }

    Promise.all(tasks).then(()=>{
      configuredCarImages = goodCars.slice();
      resolve();
    }).catch(()=>{ configuredCarImages = goodCars.slice(); resolve(); });
  });
}

/* --- SIZES & Lanes --- */
function updateSizesAndLanes(){
  const roadRect = road.getBoundingClientRect();
  const roadH = roadRect.height || (window.innerHeight * 0.84);
  const base = modes[currentMode] ? modes[currentMode].baseLaneCount : 5;
  const extra = Math.max(0, Math.floor((roadH - 420) / 80));
  activeLaneCount = Math.min(14, Math.max(3, base + extra));
  const laneH = roadH / activeLaneCount;
  const carH = Math.round(Math.max(96, Math.min( Math.round(laneH * 0.82), 900 )));
  const carW = Math.round(carH * (96/56));
  const playerH = Math.round(Math.min(carH, Math.max(72, Math.round(laneH * 0.78))));
  gameContainer.style.setProperty('--car-w', carW + 'px');
  gameContainer.style.setProperty('--car-h', carH + 'px');
  gameContainer.style.setProperty('--player-w', playerH + 'px');
  gameContainer.style.setProperty('--player-h', playerH + 'px');
}

/* draw separators & reflectors */
function calcLanesAndRender(){
  const laneCount = activeLaneCount || (modes[currentMode] ? modes[currentMode].baseLaneCount : 5);
  const r = road.getBoundingClientRect();
  const height = r.height;
  const offsetTop = r.top - gameContainer.getBoundingClientRect().top;
  lanes = [];
  const margin = Math.max(8, Math.min(16, Math.round(height * 0.02)));
  for(let i=0;i<laneCount;i++){
    const t = offsetTop + margin + (i + 0.5) * ((height - margin*2) / laneCount);
    lanes.push(t);
  }
  road.querySelectorAll('.laneSeparator').forEach(n=>n.remove());
  for(let i=1;i<laneCount;i++){
    const sep = document.createElement('div');
    sep.className = 'laneSeparator';
    sep.style.top = `${(i/ laneCount) * 100}%`;
    road.appendChild(sep);
  }
  road.querySelectorAll('.reflector').forEach(n=>n.remove());
  const centerYStep = Math.max(40, Math.round(height / 20));
  for(let y = offsetTop + centerYStep; y < offsetTop + height; y += centerYStep){
    const refl = document.createElement('div');
    refl.className = 'reflector';
    refl.style.left = `calc(50% - 3px)`;
    refl.style.top = `${y}px`;
    refl.style.zIndex = 140;
    road.appendChild(refl);
  }
  crosswalk.innerHTML = '';
  const barCount = 8;
  for(let i=0;i<barCount;i++){ const bar=document.createElement('div'); bar.className='bar'; crosswalk.appendChild(bar); }
}

/* Manage spawning & ramp */
function startSpawning(rate){
  if(spawnIntervalId !== null) clearInterval(spawnIntervalId);
  currentSpawnRate = Math.round(rate * (isTouchDevice ? mobileSpawnMultiplier : 1.0));
  // spawn inmediato
  createCar();
  spawnIntervalId = setInterval(()=>{ if(!gameOver) createCar(); }, Math.max(120, currentSpawnRate));
}
function startDifficultyRamp(){
  if(rampIntervalId) clearInterval(rampIntervalId);
  const stepMs = 7000;
  rampIntervalId = setInterval(()=> {
    if(gameOver) return;
    if(currentMode === 'hard'){
      gameSpeedMultiplier *= 1.14;
      currentSpawnRate = Math.max(160, Math.round(currentSpawnRate * 0.84));
    } else if(currentMode === 'medium'){
      gameSpeedMultiplier *= 1.08;
      currentSpawnRate = Math.max(200, Math.round(currentSpawnRate * 0.90));
    } else {
      gameSpeedMultiplier *= 1.04;
      currentSpawnRate = Math.max(260, Math.round(currentSpawnRate * 0.93));
    }
    startSpawning(currentSpawnRate);
  }, stepMs);
}

/* CREATE CAR */
function createCar(){
  if(gameOver) return;
  if(!lanes.length) return;
  let attempts = 0;
  let laneIdx = Math.floor(Math.random()*lanes.length);
  while(attempts < 8){
    const topPx = lanes[laneIdx];
    const carH = parseFloat(getComputedStyle(gameContainer).getPropertyValue('--car-h')) || 96;
    const spawnZoneTop = topPx - carH;
    const spawnZoneBottom = topPx + carH;
    let conflict = false;
    for(const c of cars){
      const r = c.getBoundingClientRect();
      if(r.top < spawnZoneBottom && (r.top + r.height) > spawnZoneTop){
        conflict = true; break;
      }
    }
    if(!conflict) break;
    laneIdx = Math.floor(Math.random()*lanes.length);
    attempts++;
  }

  const topPx = lanes[laneIdx];
  const car = document.createElement('div'); car.className='car';
  const carH = parseFloat(getComputedStyle(gameContainer).getPropertyValue('--car-h')) || 96;
  car.style.top = `${topPx - (carH/2)}px`;
  const carW = parseFloat(getComputedStyle(gameContainer).getPropertyValue('--car-w')) || 180;
  const fromLeft = Math.random() > 0.5;
  const offscreenExtra = Math.round(window.innerWidth * 0.12);
  if(fromLeft){ car.style.left = -(carW + offscreenExtra) + 'px'; car.dataset.direction='right'; car.style.transform='scaleX(1)'; }
  else { car.style.left = (gameContainer.clientWidth + carW + offscreenExtra) + 'px'; car.dataset.direction='left'; car.style.transform='scaleX(-1)'; }
  const params = modes[currentMode];
  const base = (params.speed || 4) * (isTouchDevice ? mobileSpeedMultiplier : 1.0);
  const varMax = params.speedVariance || 0.5;
  const speedFactor = Math.max(1, window.innerWidth / 900);
  const randomBoost = 1 + (Math.random()*0.25 - 0.12);
  car.dataset.speed = ((base + Math.random() * base * varMax) * randomBoost * gameSpeedMultiplier) / speedFactor;
  const img = document.createElement('img');
  if(configuredCarImages.length){
    const idx = Math.floor(Math.random()*configuredCarImages.length);
    img.src = configuredCarImages[idx];
  } else {
    const colors = ['#ff4d4d','#4da6ff','#ffd24d'];
    img.src = carSvgDataUri(colors[Math.floor(Math.random()*colors.length)]);
  }
  img.alt = 'Auto';
  car.appendChild(img);
  gameContainer.appendChild(car);
  cars.push(car);
}

/* Colision AABB shrink */
function centersOverlapMode(elA, elB){
  const a = elA.getBoundingClientRect();
  const b = elB.getBoundingClientRect();
  const shrinkMap = { easy: 0.25, medium: 0.30, hard: 0.36 };
  const s = shrinkMap[currentMode] || 0.30;
  function shrinkRect(r){
    const w = r.width; const h = r.height;
    const dx = Math.min(w * s / 2, w * 0.45);
    const dy = Math.min(h * s / 2, h * 0.45);
    return {
      left: r.left + dx,
      right: r.right - dx,
      top: r.top + dy,
      bottom: r.bottom - dy
    };
  }
  const A = shrinkRect(a);
  const B = shrinkRect(b);
  if(A.left >= A.right || A.top >= A.bottom || B.left >= B.right || B.top >= B.bottom){
    return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
  }
  return !(A.right < B.left || A.left > B.right || A.bottom < B.top || A.top > B.bottom);
}

/* player pos & movement (ahora continuo) */
function setPlayerPosition(x,y){
  updateSizesAndLanes();
  calcLanesAndRender();
  const maxX = gameContainer.clientWidth - player.clientWidth;
  const maxY = gameContainer.clientHeight - player.clientHeight;
  playerX = (typeof x === 'number') ? Math.max(0, Math.min(maxX, x)) : (gameContainer.clientWidth - player.clientWidth)/2;
  playerY = (typeof y === 'number') ? Math.max(0, Math.min(maxY, y)) : (gameContainer.clientHeight - player.clientHeight - Math.round(gameContainer.clientHeight*0.08));
  player.style.left = playerX + 'px';
  player.style.top = playerY + 'px';
}

/* movement per frame usando input vectors */
function applyInputMovement(deltaMs){
  // baseStep: píxeles por "paso" - convertimos en velocidad por frame
  let baseStep = Math.max(8, Math.round(gameContainer.clientHeight * 0.038)); // px per "step"
  // aplicamos el multiplicador global del jugador
  baseStep = Math.round(baseStep * playerSpeedMultiplier);
  // convertir a velocidad por ms (aproximado): asumimos 60fps => 16.67ms ~ 1 step
  const stepPerMs = baseStep / 16.67;
  // combinar joystick (móvil) y teclado (desktop)
  const vx = joystickVector.x + keyboardVector.x;
  const vy = joystickVector.y + keyboardVector.y;
  if(Math.abs(vx) < 0.01 && Math.abs(vy) < 0.01) return;
  // normalizar si la suma supera 1
  const mag = Math.hypot(vx, vy) || 1;
  const nx = vx / Math.max(1, mag);
  const ny = vy / Math.max(1, mag);
  // sin boost táctil para mantener velocidad "normal"
  const touchInfluence = 1.0;
  const moveX = nx * stepPerMs * deltaMs * touchInfluence;
  const moveY = ny * stepPerMs * deltaMs * touchInfluence;
  setPlayerPosition(playerX + moveX, playerY + moveY);
  // win check
  if(playerY <= (gameContainer.clientHeight * 0.06)) win();
}

/* cleanup */
function clearCars(){ cars.forEach(c=>c.remove()); cars=[]; }
function stopLoops(){
  if(spawnIntervalId!==null){ clearInterval(spawnIntervalId); spawnIntervalId=null; }
  if(rafId!==null){ cancelAnimationFrame(rafId); rafId=null; }
  if(rampIntervalId!==null){ clearInterval(rampIntervalId); rampIntervalId=null; }
  loopRunning=false;
}

/* game loop: ahora con dt y movimiento continuo */
function gameLoop(now){
  if(gameOver){ stopLoops(); return; }
  const deltaMs = Math.max(1, now - lastFrameTime);
  lastFrameTime = now;

  // mover player según input
  applyInputMovement(deltaMs);

  // mover coches
  for(let i=cars.length-1;i>=0;i--){
    const car = cars[i];
    let x = parseFloat(car.style.left);
    if(isNaN(x)) x = 0;
    const speed = parseFloat(car.dataset.speed) || (modes[currentMode].speed || 4);
    if(car.dataset.direction === 'right'){
      x += speed;
      car.style.left = x + 'px';
      const carW = parseFloat(getComputedStyle(gameContainer).getPropertyValue('--car-w')) || 180;
      if(x > gameContainer.clientWidth + carW + Math.round(window.innerWidth * 0.12)){ car.remove(); cars.splice(i,1); }
    } else {
      x -= speed;
      car.style.left = x + 'px';
      const carW = parseFloat(getComputedStyle(gameContainer).getPropertyValue('--car-w')) || 180;
      if(x < - (carW + Math.round(window.innerWidth * 0.12)) ){ car.remove(); cars.splice(i,1); }
    }
    if(centersOverlapMode(player, car)){
      if(hornAudios.length){
        try{ const h = hornAudios[Math.floor(Math.random()*hornAudios.length)]; h.currentTime = 0; h.play().catch(()=>{}); }catch(e){}
      }
      if(audioCrash){ try{ setTimeout(()=>{ audioCrash.currentTime = 0; audioCrash.play().catch(()=>{}); }, 90); }catch(e){} }
      stopBackgroundHorn();
      showGameOver();
      return;
    }
  }

  rafId = requestAnimationFrame(gameLoop);
}

/* UI/overlays */
function showGameOver(){
  gameOver = true;
  stopLoops();
  gameOverScreen.style.display = 'flex';
  gameOverScreen.setAttribute('aria-hidden','false');
}
retryBtn.addEventListener('click', ()=>{
  gameOverScreen.style.display = 'none';
  gameOverScreen.setAttribute('aria-hidden','true');
  showStartMenu();
});

/* win & restart */
function win(){ gameOver=true; stopLoops(); stopBackgroundHorn(); if(audioWin){ try{ audioWin.currentTime=0; audioWin.play().catch(()=>{}); }catch(e){} } winScreen.style.display='flex'; }
function restartSameMode(){ winScreen.style.display='none'; restartGame({keepMode:true}); }

/* menu flow */
function showStartMenu(){
  stopLoops();
  clearCars();
  gameOver = false;
  winScreen.style.display = 'none';
  gameOverScreen.style.display = 'none';
  gameContainer.setAttribute('aria-hidden','true');
  startMenu.style.display = 'flex';
  stopBackgroundHorn();
}

/* restart game */
function restartGame(opts={keepMode:false,toInitial:false}){
  stopLoops(); clearCars(); gameOver=false;
  if(opts.toInitial) currentMode = CONFIG.initialDifficulty || 'medium';
  else if(!opts.keepMode) currentMode = currentMode || CONFIG.initialDifficulty || 'medium';
  if(configuredWinImage) winImageEl.src = configuredWinImage;
  if(configuredPlayerImage) player.style.backgroundImage = `url("${configuredPlayerImage}")`;
  else player.style.backgroundImage = `url("${defaultPlayerURI}")`;
  player.style.backgroundSize = 'contain';
  player.style.backgroundRepeat = 'no-repeat';
  player.style.backgroundPosition = 'center';
  gameSpeedMultiplier = 1;
  updateSizesAndLanes();
  calcLanesAndRender();
  setPlayerPosition((gameContainer.clientWidth - player.clientWidth)/2, gameContainer.clientHeight - player.clientHeight - Math.round(gameContainer.clientHeight*0.08));
  const baseSpawn = modes[currentMode].spawnRate || 480;
  currentSpawnRate = Math.max(120, Math.round(baseSpawn * 1.0 * (isTouchDevice ? mobileSpawnMultiplier : 1.0)));
  startSpawning(currentSpawnRate);
  const burst = Math.min(18, Math.max(6, activeLaneCount * 2));
  for(let i=0;i<burst;i++){ setTimeout(()=>{ if(!gameOver) createCar(); }, i * 110); }
  startDifficultyRamp();
  startBackgroundHorn();
  if(!loopRunning){ loopRunning=true; lastFrameTime = performance.now(); rafId = requestAnimationFrame(gameLoop); }
}

/* background horn control */
function startBackgroundHorn(){
  if(backgroundHorn) return;
  if(hornPaths && hornPaths.length){
    try{
      backgroundHorn = new Audio(hornPaths[0]);
      backgroundHorn.preload = 'auto';
      backgroundHorn.loop = true;
      backgroundHorn.volume = 0.14;
      backgroundHorn.play().catch(()=>{});
    }catch(e){}
  } else if(hornAudios.length){
    try{
      backgroundHorn = new Audio(hornAudios[0].src);
      backgroundHorn.preload = 'auto';
      backgroundHorn.loop = true;
      backgroundHorn.volume = 0.14;
      backgroundHorn.play().catch(()=>{});
    }catch(e){}
  }
}
function stopBackgroundHorn(){
  try{
    if(backgroundHorn){
      backgroundHorn.pause();
      backgroundHorn.currentTime = 0;
      backgroundHorn = null;
    }
  }catch(e){}
}

/* start from menu */
async function startFromMenu(){
  const selBtn = document.querySelector('.radioBtn.active');
  currentMode = selBtn ? selBtn.dataset.val : CONFIG.initialDifficulty;
  await preloadImagesAndSounds().catch(()=>{});
  startMenu.style.display = 'none';
  gameContainer.setAttribute('aria-hidden','false');
  if(configuredWinImage) winImageEl.src = configuredWinImage;
  if(configuredPlayerImage) player.style.backgroundImage = `url("${configuredPlayerImage}")`; else player.style.backgroundImage = `url("${defaultPlayerURI}")`;
  restartGame({keepMode:false});
}

/* UI radio */
radioBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    radioBtns.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const input = btn.querySelector('input[type="radio"]');
    if(input) input.checked = true;
  });
});
startBtn.addEventListener('click', startFromMenu);

/* ---------- INPUT: teclado continuo ---------- */
const keysDown = {};
document.addEventListener('keydown',(e)=>{
  if(gameOverScreen.style.display === 'flex' || winScreen.style.display === 'flex') return;
  const k = e.key.toLowerCase();
  if(['arrowup','w','arrowdown','s','arrowleft','a','arrowright','d'].includes(k) || ['arrowup','arrowdown','arrowleft','arrowright'].includes(e.key.toLowerCase())){
    // evitar scroll con flechas
    if(['arrowup','arrowdown','arrowleft','arrowright'].includes(k) || ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
      e.preventDefault();
    }
    if(k === 'arrowup' || k === 'w') keysDown.up = true;
    if(k === 'arrowdown' || k === 's') keysDown.down = true;
    if(k === 'arrowleft' || k === 'a') keysDown.left = true;
    if(k === 'arrowright' || k === 'd') keysDown.right = true;
    updateKeyboardVector();
  }
  if(k === 'r') restartSameMode();
});
document.addEventListener('keyup',(e)=>{
  const k = e.key.toLowerCase();
  if(k === 'arrowup' || k === 'w') keysDown.up = false;
  if(k === 'arrowdown' || k === 's') keysDown.down = false;
  if(k === 'arrowleft' || k === 'a') keysDown.left = false;
  if(k === 'arrowright' || k === 'd') keysDown.right = false;
  updateKeyboardVector();
});
function updateKeyboardVector(){
  let x = 0, y = 0;
  if(keysDown.left) x -= 1;
  if(keysDown.right) x += 1;
  if(keysDown.up) y -= 1;
  if(keysDown.down) y += 1;
  // normalizar
  const mag = Math.hypot(x,y) || 1;
  keyboardVector.x = x / Math.max(1, mag);
  keyboardVector.y = y / Math.max(1, mag);
}

/* ---------- JOYSTICK: pointer API ---------- */
let joystickActive = false;
let joystickPointerId = null;
let baseRect = null;
let maxRadius = 40; // px knob travel (ajustable)
function showJoystickIfTouch(){
  if(isTouchDevice){
    joystick.style.display = 'block';
    joystick.setAttribute('aria-hidden','false');
    // recalcular radios
    baseRect = joystickBase.getBoundingClientRect();
    maxRadius = Math.min(baseRect.width, baseRect.height) * 0.36;
  } else {
    joystick.style.display = 'none';
    joystick.setAttribute('aria-hidden','true');
  }
}
showJoystickIfTouch();
window.addEventListener('resize', showJoystickIfTouch);

function resetJoystick(){
  joystickVector.x = 0; joystickVector.y = 0;
  joystickKnob.style.transform = `translate(0px,0px)`;
  joystickActive = false;
  joystickPointerId = null;
}

joystickBase.addEventListener('pointerdown', (ev)=>{
  if(ev.pointerType === 'mouse') return; // ignorar clicks mouse; desktop usa teclado
  ev.preventDefault();
  joystickBase.setPointerCapture(ev.pointerId);
  joystickActive = true;
  joystickPointerId = ev.pointerId;
  baseRect = joystickBase.getBoundingClientRect();
  maxRadius = Math.min(baseRect.width, baseRect.height) * 0.36;
  handleJoystickMove(ev.clientX, ev.clientY);
});
window.addEventListener('pointermove', (ev)=>{
  if(!joystickActive || ev.pointerId !== joystickPointerId) return;
  ev.preventDefault();
  handleJoystickMove(ev.clientX, ev.clientY);
});
window.addEventListener('pointerup', (ev)=>{
  if(ev.pointerId !== joystickPointerId) return;
  try{ joystickBase.releasePointerCapture(ev.pointerId); }catch(e){}
  resetJoystick();
});
window.addEventListener('pointercancel', (ev)=>{
  if(ev.pointerId !== joystickPointerId) return;
  resetJoystick();
});

function handleJoystickMove(clientX, clientY){
  if(!baseRect) baseRect = joystickBase.getBoundingClientRect();
  const cx = baseRect.left + baseRect.width/2;
  const cy = baseRect.top + baseRect.height/2;
  let dx = clientX - cx;
  let dy = clientY - cy;
  // limitar a maxRadius
  const dist = Math.hypot(dx,dy);
  const limiting = dist > maxRadius ? maxRadius / dist : 1;
  dx *= limiting; dy *= limiting;
  // actualizar knob
  joystickKnob.style.transition = 'transform 0s';
  joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;
  // vector normalizado en -1..1
  // FIX: ahora Y conserva el mismo signo que el teclado (arriba => negativo), antes estaba invertido
  joystickVector.x = +(dx / maxRadius).toFixed(4);
  joystickVector.y = +(dy / maxRadius).toFixed(4); // <= cambio clave: sin invertir el signo
}

/* quitar transición extra al soltar */
joystickKnob.addEventListener('transitionend', ()=>{ joystickKnob.style.transition = ''; });

/* prevent double-tap zoom extra */
let lastTap = 0;
gameContainer.addEventListener('touchend', (e)=> {
  const now = Date.now();
  if(now - lastTap < 300){ e.preventDefault(); }
  lastTap = now;
}, {passive:false});

/* resize */
window.addEventListener('resize', ()=>{
  updateSizesAndLanes();
  calcLanesAndRender();
  setPlayerPosition(playerX, playerY);
});

/* load */
window.addEventListener('load', async ()=>{
  if(!modes[currentMode]) currentMode = 'medium';
  await preloadImagesAndSounds().catch(()=>{});
  updateSizesAndLanes();
  calcLanesAndRender();
  if(configuredPlayerImage) player.style.backgroundImage = `url("${configuredPlayerImage}")`; else player.style.backgroundImage = `url("${defaultPlayerURI}")`;
  player.style.backgroundSize = 'contain';
  player.style.backgroundRepeat = 'no-repeat';
  player.style.backgroundPosition = 'center';
  setPlayerPosition();
  // mostrar joystick si corresponde
  showJoystickIfTouch();
});
</script>
</body>
</html>
